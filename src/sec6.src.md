# Производный тип и абстрактный тип

## Производный тип

Существует два вида типов: финальный тип и производный тип.
Финальный тип не имеет дочерних объектов.
Производный тип имеет дочерние объекты.

Основное различие между этими двумя объектами заключается в их классах.
Объекты финального типа не имеют собственной области класса.
Единственный член класса - это его родительский класс.

Производный объект имеет собственную область в классе.
Класс открыт для своих потомков.

`G_DECLARE_DERIVABLE_TYPE` используется для объявления производного типа.
Он записывается в заголовочном файле следующим образом:

~~~C
#define T_TYPE_NUMBER             (t_number_get_type ())
G_DECLARE_DERIVABLE_TYPE (TNumber, t_number, T, NUMBER, GObject)
~~~

## Абстрактный тип

Абстрактный тип не имеет экземпляров.
Этот тип объекта является производным, и его потомки могут использовать функции и сигналы абстрактного объекта.

Примерами этого раздела являются объекты TNumber, TInt и TDouble.
TInt и TDouble уже были созданы в предыдущем разделе.
Они представляют целые числа и числа с плавающей точкой соответственно.
Числа более абстрактны, чем целые числа и числа с плавающей точкой.

TNumber - это абстрактный объект, который представляет числа.
TNumber является родительским объектом для TInt и TDouble.
TNumber не создается в виде экземпляра, потому что его тип абстрактный.
Когда экземпляр имеет тип TInt или TDouble, он также является экземпляром TNumber.

TInt и TDouble имеют пять операций: сложение, вычитание, умножение, деление и унарная операция минус.
Эти операции могут быть определены для объекта TNumber.

В этом разделе мы определим объект TNumber и пять функций выше.
Кроме того, будет добавлена функция `to_s`.
Она преобразует значение TNumber в строку.
Это похоже на функцию sprintf.
И мы перепишем TInt и TDouble для реализации этих функций.

## Класс TNumber

`tnumber.h` - это заголовочный файл для класса TNumber.

@@@include
tnumber/tnumber.h
@@@

- 6: Макрос `G_DECLARE_DERIVABLE_TYPE`.
Он похож на макрос `G_DECLARE_FINAL_TYPE`.
Различие в том, производный тип или финальный.
`G_DECLARE_DERIVABLE_TYPE` раскрывается в:
  - Объявление функции `t_number_get_type ()`. Эта функция должна быть определена в файле `tnumber.c`. Определение обычно делается с помощью макроса `G_DEFINE_TYPE` или его семейства макросов.
  - Определение экземпляра TNumber, единственным членом которого является только его родитель.
  - Объявление TNumberClass. Он должен быть определен позже в заголовочном файле.
  - Определяются вспомогательные макросы `T_NUMBER` (приведение к экземпляру), `T_NUMBER_CLASS` (приведение к классу), `T_IS_NUMBER` (проверка экземпляра), `T_IS_NUMBER_CLASS` (проверка класса) и `T_NUMBER_GET_CLASS`.
  - Поддержка `g_autoptr()`.
- 8-18: Определение структуры TNumberClass.
- 10-15: Это указатели на функции.
Они называются методами класса или виртуальными функциями.
Ожидается, что они будут переопределены в объекте-потомке.
Методы - это пять арифметических операторов и функция `to_s`.
Функция `to_s` похожа на функцию sprintf.
- 17: Указатель на обработчик сигнала "div-by-zero" по умолчанию.
Смещение этого указателя передается в `g_signal_new` в качестве аргумента.
- 22-38: Функции. Они публичные.

`tnumber.c` выглядит следующим образом.

@@@include
tnumber/tnumber.c
@@@

- 5: Макрос `G_DEFINE_ABSTRACT_TYPE`.
Этот макрос используется для определения объекта абстрактного типа.
Абстрактный тип не создается в виде экземпляра.
Этот макрос раскрывается в:
  - Объявление функции `t_number_init ()`.
  - Объявление функции `t_number_class_init ()`.
  - Определение функции `t_number_get_type ()`.
  - Определение статической переменной `t_number_parent_class`, которая указывает на родительский класс.
- 3, 7-10, 26-35: Определяет сигнал деления на ноль.
Функция `div_by_zero_default_cb` является обработчиком по умолчанию для сигнала "div-by-zero".
Обработчик по умолчанию не имеет параметра пользовательских данных.
Используется функция `g_signal_new` вместо `g_signal_new_class_handler`.
Она указывает обработчик как смещение от начала класса до указателя на обработчик.
- 12-36: Функция инициализации класса `t_number_class_init`.
- 16-21: Эти методы класса являются виртуальными функциями.
Ожидается, что они будут переопределены в объекте-потомке TNumber.
Здесь присваивается NULL, чтобы ничего не происходило при вызове методов.
- 23: Присваивает адрес функции `dev_by_zero_default_cb` в `class->div_by_zero`.
Это обработчик по умолчанию для сигнала "div-by-zero".
- 38-40: `t_number_init` - это функция инициализации экземпляра.
Но абстрактный объект не создается в виде экземпляра.
Поэтому в этой функции ничего не делается.
Но нельзя опускать определение этой функции.
- 42-98: Публичные функции.
Эти функции просто вызывают соответствующие методы класса, если указатель на метод класса не равен NULL.

## Объект TInt.

`tint.h` - это заголовочный файл класса TInt.
TInt является дочерним классом TNumber.

@@@include
tnumber/tint.h
@@@

- 9-13: Объявляет публичные функции.
Арифметические функции и `to_s` объявлены в TNumber, поэтому TInt не объявляет эти функции.
Объявлены только функции создания экземпляров.

Файл C `tint.c` реализует виртуальные функции (методы класса).
И указатели методов в TNumberClass переписываются здесь.

@@@include
tnumber/tint.c
@@@

- 5-6, 15-33, 127-130: Определение свойства "value".
Это то же самое, что и раньше.
- 8-11: Определение структуры TInt.
Это должно быть определено перед `G_DEFINE_TYPE`.
- 13: Макрос `G_DEFINE_TYPE`.
Этот макрос раскрывается в:
  - Объявление функции `t_int_init ()`.
  - Определение функции `t_int_get_type ()`.
  - Определение статической переменной `t_int_parent_class`, которая указывает на родительский класс.
- 35-37: `t_int_init`.
- 41-112: Эти функции связаны с указателями на методы класса в TIntClass.
Они являются реализацией виртуальных функций, определенных в `tnumber.c`.
- 41-50: Определяет макрос, используемый в `t_int_add`, `t_int_sub` и `t_int_mul`.
Этот макрос похож на функцию `t_int_div`.
См. объяснение ниже для `t_int_div`.
- 52-71: Функции `t_int_add`, `t_int_sub` и `t_int_mul`.
Используется макрос `t_int_binary_op`.
- 73-95: Функция `t_int_div`.
Первый аргумент `self` - это объект, для которого вызывается функция.
Второй аргумент `other` - это другой объект TNumber.
Это может быть TInt или TDouble.
Если это TDouble, его значение приводится к int перед выполнением деления.
Если делитель (`other`) равен нулю, испускается сигнал "div-by-zero".
Сигнал определен в TNumber, поэтому TInt не знает идентификатор сигнала.
Поэтому испускание выполняется с помощью `g_signal_emit_by_name` вместо `g_signal_emit`.
Возвращаемое значение `t_int_div` - это объект типа TNumber
Однако, поскольку TNumber является абстрактным, фактический тип объекта - TInt.
- 97-102: Функция для унарного оператора минус.
- 104-112: Функция `to_s`. Эта функция преобразует int в строку.
Например, если значение объекта равно 123, то результатом будет строка "123".
Вызывающая сторона должна освободить строку, если она становится ненужной.
- 114- 131: Функция инициализации класса `t_int_class_init`.
- 120-125: Методы класса переопределяются.
Например, если `t_number_add` вызывается для объекта TInt, то функция вызывает метод класса `*tnumber_class->add`.
Указатель указывает на функцию `t_int_add`.
Следовательно, в конечном итоге вызывается `t_int_add`.
- 133-147: Функции создания экземпляров такие же, как и раньше.

## Объект TDouble.

Объект TDouble определяется с помощью `tdouble.h` и `tdouble.c`.
Определение очень похоже на TInt.
Поэтому этот подраздел просто показывает содержимое файлов.

tdouble.h

@@@include
tnumber/tdouble.h
@@@

tdouble.c

@@@include
tnumber/tdouble.c
@@@

## main.c

`main.c` - это простая программа для тестирования объектов.

@@@include
tnumber/main.c
@@@

- 6-20: Обработчик "notify".
Этот обработчик улучшен для поддержки как TInt, так и TDouble.
- 22-71: Функция `main`.
- 30-31: Подключает сигналы notify к `i` (TInt) и `d` (TDouble).
- 33-34: Устанавливает свойства "value" для `i` и `d`.
- 36: Добавить `d` к `i`.
Ответ - объект TInt.
- 47: Добавить `i` к `d`.
Ответ - объект TDouble.
Сложение двух объектов TNumber не является коммутативным, потому что тип результата будет другим, если два объекта поменять местами.
- 56-63: Тестирует сигнал деления на ноль.

## Компиляция и выполнение

Исходные файлы находятся в [src/tnumber](tnumber).
Файл `meson.buld`, который управляет процессом компиляции, выглядит следующим образом.

@@@include
tnumber/meson.build
@@@

Компиляция и выполнение выполняются обычным способом.

~~~
$ cd src/tnumber
$ meson setup _build
$ ninja -C _build
$ _build/tnumber
~~~

Затем на дисплее отображается следующее.

~~~
Property "value" is set to 100.
Property "value" is set to 12.345000.
100 + 12.345000 is 112.
12.345000 + 100 is 112.345000.
Property "value" is set to 0.000000.

Error: division by zero.
~~~

Два ответа разные из-за разных типов.

Этот раздел показал простой пример производного и абстрактного класса.
Вы можете определить свой производный объект таким образом.
Если ваш объект не абстрактный, используйте `G_DEFINE_TYPE` вместо `G_DEFINE_ABSTRACT_TYPE`.
И вам нужно еще одно - как управлять приватными данными в вашем производном объекте.
Есть руководство в [GObject API Reference](https://docs.gtk.org/gobject/tutorial.html#gobject-tutorial).
См. руководство для изучения производного объекта.

Также полезно посмотреть исходные файлы в GTK.

## Процесс инициализации класса

### Процесс инициализации TNumberClass

Поскольку TNumber является абстрактным объектом, вы не можете создать его экземпляр напрямую.
И вы также не можете создать класс TNumber.
Но когда вы создаете экземпляр его потомка, класс TNumber создается и инициализируется.
Первый вызов `g_object_new (T_TYPE_INT, ...)` или `g_object_new (T_TYPE_DOUBLE, ...)` создает и инициализирует TNumberClass, если класс не существует.
После этого создается TIntClass или TDoubleClass, и затем следует создание экземпляра TInt или TDouble соответственно.

И процесс инициализации класса TNumber выглядит следующим образом.

1. GObjectClass был инициализирован до запуска функции `main`.
2. Выделяется память для TNumberClass.
3. Родительская (GObjectClass) часть класса копируется из GObjectClass.
4. Вызывается функция инициализации класса `t_number_class_init`.
Она инициализирует методы класса (указатели на методы класса) и обработчик сигнала по умолчанию.

Диаграмма ниже показывает процесс.

![TNumberClass initialization](../image/tnumberclass_init.png){width=12cm height=9cm}

### Процесс инициализации TIntClass

1. TNumberClass был инициализирован до начала инициализации TIntClass.
2. Первый вызов `g_object_new (T_TYPE_INT, ...)` инициализирует TIntClass.
И процесс инициализации выглядит следующим образом.
3. Выделяется память для TIntClass.
TIntClass не имеет собственной области.
Следовательно, его структура такая же, как у его родительского класса (TNumberClass).
4. Родительская (TNumberClass) часть класса (это то же самое, что и весь TIntClass) копируется из TNumberClass.
5. Вызывается функция инициализации класса `t_int_class_init`.
Она переопределяет методы класса из TNumber, `set_property` и `get_property`.

Диаграмма ниже показывает процесс.

![TIntClass initialization](../image/tintclass_init.png){width=12cm height=9cm}
