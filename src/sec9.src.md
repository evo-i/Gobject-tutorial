# Интерфейс

Интерфейс похож на абстрактный класс.
Интерфейс определяет виртуальные функции, которые должны быть переопределены функцией в другом создаваемом объекте.

Этот раздел содержит простой пример, TComparable.
TComparable — это интерфейс.
Он определяет функции для сравнения.
Они следующие:

- `t_comparable_cmp (self, other)`: Сравнивает `self` и `other`.
Первый аргумент `self` — это экземпляр, на котором выполняется `t_comparable_cmp`.
Второй аргумент `other` — это другой экземпляр.
Эта функция должна быть переопределена в объекте, который реализует интерфейс.
  - Если `self` равен `other`, `t_comparable_cmp` возвращает 0.
  - Если `self` больше чем `other`, `t_comparable_cmp` возвращает 1.
  - Если `self` меньше чем `other`, `t_comparable_cmp` возвращает -1.
  - Если происходит ошибка, `t_comparable_cmp` возвращает -2.
- `t_comparable_eq (self, other)`: Возвращает TRUE, если `self` равен `other`.
В противном случае возвращает FALSE.
Обратите внимание, что FALSE возвращается даже при возникновении ошибки.
- `t_comparable_gt (self, other)`: Возвращает TRUE, если `self` больше чем `other`.
В противном случае возвращает FALSE.
- `t_comparable_lt (self, other)`: Возвращает TRUE, если `self` меньше чем `other`.
В противном случае возвращает FALSE.
- `t_comparable_ge (self, other)`: Возвращает TRUE, если `self` больше или равен `other`.
В противном случае возвращает FALSE.
- `t_comparable_le (self, other)`: Возвращает TRUE, если `self` меньше или равен `other`.
В противном случае возвращает FALSE.

Числа и строки можно сравнивать.
TInt, TDouble и TStr реализуют интерфейс TComparable, поэтому они могут использовать вышеуказанные функции.
Кроме того, TNumStr может использовать эти функции, потому что является дочерним классом TStr.

Например,

~~~C
TInt *i1 = t_int_new_with_value (10);
TInt *i2 = t_int_new_with_value (20);
t_comparable_eq (T_COMPARABLE (i1), T_COMPARABLE (i2)); /* => FALSE */
t_comparable_lt (T_COMPARABLE (i1), T_COMPARABLE (i2)); /* => TRUE */
~~~

В чем разница между интерфейсом и абстрактным классом?
Виртуальные функции в абстрактном классе переопределяются функцией в его классах-потомках.
Виртуальные функции в интерфейсе переопределяются функцией в любых классах.
Сравните TNumber и TComparable.

- Функция `t_number_add` переопределяется в TIntClass и TDoubleClass.
Она не может быть переопределена в TStrClass, потому что TStr не является потомком TNumber.
- Функция `t_comparable_cmp` переопределяется в TIntClass, TDoubleClass и TStrClass.

## Интерфейс TComparable

Определение интерфейсов похоже на определение объектов.

- Используйте `G_DECLARE_INTERFACE` вместо `G_DECLARE_FINAL_TYPE`.
- Используйте `G_DEFINE_INTERFACE` вместо `G_DEFINE_TYPE`.

Теперь рассмотрим заголовочный файл.

@@@include
tcomparable/tcomparable.h
@@@

- 6: Макрос `G_DECLARE_INTERFACE`.
Последний параметр является предварительным требованием интерфейса.
Предварительным требованием для TComparable является GObject.
Таким образом, любой другой объект, кроме потомков GObject, например GVariant, не может реализовать TComparable.
Предварительное требование — это GType интерфейса или класса.
Этот макрос раскрывается в:
  - Объявление `t_comparable_get_type()`.
  - `Typedef struct _TComparableInterface TComparableInterface`
  - Макрос `T_COMPARABLE ()`. Он приводит экземпляр к типу TComparable.
  - Макрос `T_IS_COMPARABLE ()`. Он проверяет, является ли тип экземпляра `T_TYPE_COMPARABLE`.
  - Макрос `T_COMPARABLE_GET_IFACE ()`. Он получает интерфейс экземпляра, который передается в качестве аргумента.
- 8-14: Структура `TComparableInterface`.
Это похоже на структуру класса.
Первый член — это родительский интерфейс.
Родителем `TComparableInterface` является `GTypeInterface`.
`GTypeInterface` является базой для всех типов интерфейсов.
Это аналогично `GTypeClass`, который является базой для всех типов классов.
`GTypeClass` — это первый член структуры `GObjectClass`.
(См. `gobject.h`. Обратите внимание, что `GObjectClass` — это то же самое, что `struct _GObjectClass`.)
Следующий член — это указатель `arg_error` на обработчик сигнала по умолчанию для сигнала "arg-error".
Этот сигнал генерируется, когда второй аргумент функции сравнения неподходящий.
Например, если `self` — это TInt, а `other` — это TStr, оба они являются экземплярами Comparable.
Но их *нельзя* сравнить.
Это потому, что `other` не является TNumber.
Последний член `cmp` — это указатель на метод сравнения.
Это виртуальная функция, которая должна быть переопределена функцией в объекте, реализующем интерфейс.
- 22-38: Публичные функции.

C файл `tcomparable.c` следующий.

@@@include
tcomparable/tcomparable.c
@@@

- 5: Макрос `G_DEFINE_INTERFACE`.
Третий параметр — это тип предварительного требования.
Этот макрос раскрывается в:
  - Объявление `t_comparable_default_init ()`.
  - Определение `t_comparable_get_type ()`.
- 7-10: `arg_error_default_cb` — обработчик сигнала по умолчанию для сигнала "arg-error".
- 12- 29: Функция `t_comparable_default_init`.
Эта функция похожа на функцию инициализации класса.
Она инициализирует структуру `TComparableInterface`.
- 15: Присваивает NULL значению `cmp`.
Таким образом, метод сравнения не работает до тех пор, пока класс реализации не переопределит его.
- 17: Устанавливает обработчик сигнала по умолчанию для сигнала "arg-error".
- 18-28: Создает сигнал "arg-error".
- 31-38: Функция `t_comparable_cmp`.
Она проверяет тип `self` на первой строке.
Если он не является сравниваемым, она записывает сообщение об ошибке и возвращает -2 (ошибка).
Если `iface->cmp` равен NULL (это означает, что метод класса не был переопределен), то возвращается -2.
В противном случае вызывается метод класса и возвращается значение, возвращенное методом класса.
- 40-65: Публичные функции.
Эти пять функций основаны на `t_comparable_cmp`.
Поэтому для них не требуется переопределение.
Например, `t_comparable_eq` просто вызывает `t_comparable_cmp`.
И возвращает TRUE, если `t_comparable_cmp` возвращает ноль.
В противном случае возвращает FALSE.

Эта программа использует сигнал для передачи пользователю информации об ошибке типа аргумента.
Эта ошибка обычно является программной ошибкой, а не ошибкой времени выполнения.
Использование сигнала для сообщения о программной ошибке — не лучший способ.
Лучший способ — использовать `g_return_if_fail`.
Причина, по которой я создал этот сигнал, заключается в том, что я хотел показать, как реализовать сигнал в интерфейсах.

## Реализация интерфейса

TInt, TDouble и TStr реализуют TComparable.
Сначала рассмотрим TInt.
Заголовочный файл такой же, как и раньше.
Реализация написана в C файле.

`tint.c` следующий.

@@@include
tcomparable/tint.c
@@@

- 4: Необходимо включить заголовочный файл TComparable.
- 19: Объявление функции `t_comparable_interface_init ()`.
Это объявление должно быть сделано перед макросом `G_DEFINE_TYPE_WITH_CODE`.
- 21-22: Макрос `G_DEFINE_TYPE_WITH_CODE`.
Последний параметр — это макрос `G_IMPLEMENT_INTERFACE`.
Второй параметр `G_IMPLEMENT_INTERFACE` — это `t_comparable_interface_init`.
Эти два макроса раскрываются в:
  - Объявление `t_int_class_init ()`.
  - Объявление `t_int_init ()`.
  - Определение статической переменной `t_int_parent_class`, которая указывает на родительский класс.
  - Определение `t_int_get_type ()`.
Эта функция включает `g_type_register_static_simple ()` и `g_type_add_interface_static ()`.
Функция `g_type_register_static_simple ()` — это удобная версия `g_type_register_static ()`.
Она регистрирует тип TInt в системе типов.
Функция `g_type_add_interface_static ()` добавляет тип интерфейса к типу экземпляра.
Хороший пример есть в [GObject Reference Manual, Interfaces](https://docs.gtk.org/gobject/concepts.html#non-instantiatable-classed-types-interfaces).
Если вы хотите узнать, как писать код без макросов, см. [`tint_without_macro.c`](tcomparble/tint_without_macro.c).
- 24-48: `t_int_comparable_cmp` — это функция для сравнения экземпляра TInt с экземпляром TNumber.
- 26-29: Проверяет тип `other`.
Если тип аргумента не TNumber, генерируется сигнал "arg-error" с помощью `g_signal_emit_by_name`.
- 34: Преобразует `self` в double.
- 35-39: Получает значение `other`, и если это TInt, то значение приводится к double.
- 40-47: сравнивает `s` и `o` и возвращает 1, 0, -1 и -2.
- 50-53: `t_comparable_interface_init`.
Эта функция вызывается в процессе инициализации TInt.
Функция `t_int_comparable_cmp` присваивается `iface->cmp`.

`tdouble.c` почти такой же, как `tint.c`.
Эти два объекта можно сравнивать, потому что int приводится к double перед сравнением.

`tstr.c` следующий.

@@@include
tcomparable/tstr.c
@@@

- 16: Объявляет функцию `t_comparable_interface_init`.
Она должна быть объявлена перед макросом `G_DEFINE_TYPE_WITH_CODE`.
- 18-20: Макрос `G_DEFINE_TYPE_WITH_CODE`.
Поскольку TStr является производным типом, необходима его приватная область (TStrPrivate).
Макрос `G_ADD_PRIVATE` создает приватную область.
Обратите внимание, что после макроса `G_ADD_PRIVATE` нет запятой.
- 68-92: `t_str_comparable_cmp`.
- 70-73: Проверяет тип `other`.
Если это не TStr, генерируется сигнал "arg-error".
- 78-79: Получает строки `s` и `o` из объектов TStr `self` и `other`.
- 81-88: Сравнивает `s` и `o` с помощью стандартной функции C `strcmp`.
- 89-90: Освобождает `s` и `o`.
- 91: Возвращает результат.
- 94-97: Функция `t_comparable_interface_init`.
Она переопределяет `iface->comp` на `t_str_comparable_cmp`.

TStr можно сравнивать с TStr, но не с TInt и не с TDouble.
Обычно сравнение доступно между двумя экземплярами одного типа.

TNumStr сам по себе не реализует TComparable.
Но он является потомком TStr, поэтому он сравниваем.
Сравнение основано на алфавитном порядке.
Таким образом, "a" больше чем "b", а "three" больше чем "two".

## Тестовая программа.

`main.c` — это тестовая программа.

@@@include
tcomparable/main.c
@@@

- 8-42: Функция `t_print` имеет три параметра и формирует выходную строку, затем отображает ее на дисплее.
При формировании вывода строки окружаются двойными кавычками.
- 44-58: Функция `compare` сравнивает два объекта TComparable и вызывает `t_print` для отображения результата.
- 60-87: Функция `main`.
- 69-73: Создает экземпляры TInt, TDouble и три TStr.
Им присваиваются значения.
- 75: Сравнивает TInt и TDouble.
- 76-77: Сравнивает два TStr.
- 78: Сравнивает TInt с TStr.
Это вызывает "arg-error".
- 80-84 Освобождает объекты.

## Компиляция и выполнение

Измените текущий каталог на [src/tcomparable](comparable).

~~~
$ cd src/tcomparable
$ meson setup _build
$ ninja -C _build
~~~

Затем выполните его.

~~~
$ _build/tcomparable
124 is greater than 123.450000.
"one" is less than "two".
"two" is greater than "three".

TComparable: argument error.

TComparable: argument error.

TComparable: argument error.

TComparable: argument error.

TComparable: argument error.
124 can't compare to "one".
~~~

## Создание интерфейса без макросов

Мы использовали макросы, такие как `G_DECLARE_INTERFACE`, `G_DEFINE_INTERFACE` для создания интерфейса.
И `G_DEFINE_TYPE_WITH_CODE` для реализации интерфейса.
Мы также можем создать его без макросов.
В каталоге `tcomparable` есть три файла.

- `tcomparable_without_macro.h`
- `tcomparable_without_macro.c`
- `tint_without_macro.c`

Они не используют макросы.
Вместо этого они регистрируют интерфейс или реализацию интерфейса в системе типов напрямую.
Если вы хотите узнать это, см. исходные файлы в [src/tcomparable](tcomparable).

## Система GObject и объектно-ориентированные языки

Если вы знаете какие-либо объектно-ориентированные языки, вы, вероятно, подумали, что GObject и эти языки похожи.
Изучение таких языков очень полезно для понимания системы GObject.
