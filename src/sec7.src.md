# Производный и не абстрактный тип

Гораздо чаще создают не абстрактный производный тип, чем абстрактный тип.
Этот раздел описывает, как создавать объекты не абстрактного производного типа.
Примером производного типа является объект для строки.
Это TStr.
А его потомок — это объект для числовой строки.
Числовая строка — это строка, которая выражает число.
Например, "0", "-100" и "123.45".
Дочерний объект (числовая строка) будет объяснен в следующем разделе.

Этот раздел описывает управление памятью для строк перед производными объектами.

## Строка и управление памятью

TStr имеет значение строкового типа.
Это похоже на TInt или TDouble, но строка более сложна, чем int и double.
При создании программы TStr нужно быть внимательным к управлению памятью, что не требуется для TInt и TDouble.

### Строка и память

Строка — это массив символов, который завершается '\0'.
Строка не является типом C, таким как char, int, float или double.
Но указатель на массив символов ведет себя как строковый тип других языков.
Поэтому мы часто называем указатель строкой.

Если указатель равен NULL, он ни на что не указывает.
Таким образом, указатель не является строкой.
Программы со строками будут содержать ошибки, если вы не будете осторожны с NULL-указателем.

Другая раздражающая проблема — это выделение памяти.
Поскольку строка — это массив символов, выделение памяти необходимо для создания новой строки.
Мы не забываем выделять память, но часто забываем освобождать память.
Это вызывает утечку памяти.

~~~C
char *s;
s = g_strdup ("Hello.");
... ... ... do something with s
g_free (s);
~~~

`g_strdup` дублирует строку.
Она выполняет:

- Вычисляет размер строки.
Размер "Hello." равен 7, потому что строки завершаются нулем.
Строка — это массив 'H', 'e', 'l', 'l', 'o', '.' и ноль ('\0').
- Запрашивает у системы выделение 7 байт памяти.
- Копирует строку в память.
- Возвращает указатель на вновь выделенную память.
- Если аргумент равен NULL, то память не выделяется, и она возвращает NULL.

Если строка `s` больше не используется, `s` должна быть освобождена, что означает, что выделенные 7 байт должны быть возвращены системе.
`g_free` освобождает память.

Строки, ограниченные двойными кавычками, как "Hello.", являются строковыми литералами.
Они являются массивом символов, но содержимое массива не может быть изменено.
И они не должны быть освобождены.
Если вы записываете символ в строковый литерал или освобождаете строковый литерал, результат не определен.
Возможно, произойдут плохие вещи, например, ошибка сегментации.

Существует разница между массивами и указателями, когда вы инициализируете их строковым литералом.
Если массив инициализируется строковым литералом, массив может быть изменен.

~~~C
char a[]="Hello!";
a[1]='a';
g_print ("%s\n", a); /* Hallo will appear on your display. */
~~~

Первая строка инициализирует массив `a`.
Инициализация не простая.
Сначала компилятор вычисляет длину "Hello!".
Она равна семи, потому что строковый литерал имеет '\0' в конце.
Затем семь байт памяти выделяется в статической памяти или памяти стека.
Это зависит от класса массива, будь то `static` или `auto`.
Память инициализируется "Hello!".
Таким образом, строка в массиве может быть изменена.
Эта программа успешно отображает `Hallo!.

Первая строка программы выше эквивалентна следующей.

~~~C
char a[] = {'H', 'e', 'l', 'l', 'o', '!', '\0'};
~~~

Если вы определяете указатель со строковым литералом, вы не можете изменить строку, на которую указывает указатель.

~~~C
char *a = "Hello";
*(a+1) = 'a'; /* This is illegal. */
g_print ("%s\n", a);
~~~

Первая строка просто присваивает адрес строкового литерала переменной `a`.
Строковый литерал — это массив символов, но он доступен только для чтения.
Он может находиться в области кода программы или в какой-либо другой области, недоступной для записи.
Это зависит от реализации вашего компилятора.
Поэтому вторая строка пытается записать символ 'a' в память, доступную только для чтения, и результат не определен, например, происходит ошибка сегментации.
В любом случае, не пишите такую программу.

В заключение, строка — это массив символов, и она размещается в одном из следующих мест.

- Память только для чтения.
Строковый литерал доступен только для чтения.
- Стек.
Если класс массива `auto`, то массив размещается в стеке.
Стек доступен для записи.
Если массив определен в функции, его класс по умолчанию — `auto`.
Область стека исчезнет, когда функция вернется вызывающей стороне.
- Статическая область.
Если класс массива `static`, то массив размещается в статической области.
Он сохраняет свое значение и остается на протяжении всей жизни программы.
Эта область доступна для записи.
- Куча.
Вы можете выделять и освобождать память для строки.
Для выделения используется `g_new` или `g_new0`.
Для освобождения используется `g_free`.

### Копирование строки

Существует два способа копирования строки.
Первый способ — это просто копирование указателя.

~~~C
char *s = "Hello";
char *t = s;
~~~

Два указателя `s` и `t` указывают на один и тот же адрес.
Следовательно, вы не можете изменить `t`, потому что `t` указывает на строковый литерал, который доступен только для чтения.

Второй способ — это создание памяти и копирование строки в память.

~~~C
char *s = "Hello";
char *t = g_strdup (s);
~~~

Функция `g_strdup` выделяет память и инициализирует её "Hello", затем возвращает указатель на память.
Функция `g_strdup` почти идентична функции `string_dup` ниже.

~~~C
#include <glib-object.h>
#include <string.h>

char *
string_dup (char *s) {
  int length;
  char *t;

  if (s == NULL)
    return NULL;
  length = strlen (s) + 1;
  t = g_new (char, length);
  strcpy (t, s);
  return t;
}
~~~

Если используется `g_strdup`, два указателя `s` и `t` указывают на разные области памяти.
Вы можете изменить `t`, потому что он размещен в памяти, выделенной из области кучи.

Важно знать разницу между присваиванием указателей и дублированием строк.

### Квалификатор const

Квалификатор `const` делает так, что переменная не изменит свое значение.
Он также может быть применен к массиву.
Тогда элементы массива не будут изменены.

~~~C
const double pi = 3.1415926536;
const char a[] = "read only string";
~~~

Параметр массива в функции может быть квалифицирован с помощью `const`, чтобы указать, что функция не изменяет массив.
Точно так же возвращаемое значение (указатель на массив или строку) функции может быть квалифицировано с помощью `const`.
Вызывающая сторона не должна изменять или освобождать возвращенный массив или строку.

~~~C
char *
string_dup (const char *s) {
  ... ...
}

const char *
g_value_get_string (const GValue *value);
~~~

Квалификатор `const` указывает, кто является владельцем строки, когда он используется в функции объектов.
"Владелец" — это объект или вызывающая сторона функции, которая имеет право изменять или освобождать строку.

Например, `g_value_get_string` получает `const GValue *value` в качестве аргумента.
GValue, на которое указывает `value`, принадлежит вызывающей стороне, и функция не изменяет и не освобождает его.
Функция возвращает строку, квалифицированную с помощью `const`.
Возвращенная строка принадлежит объекту, и вызывающая сторона не должна изменять или освобождать строку.
Возможно, что строка будет изменена или освобождена объектом позже.

## Заголовочный файл

Остальная часть этого раздела посвящена TStr.
TStr является потомком GObject и содержит строку.
Строка — это указатель и массив символов.
Указатель указывает на массив.
Указатель может быть NULL.
Если он NULL, TStr не имеет массива.
Память массива берется из области кучи.
TStr владеет памятью и отвечает за её освобождение, когда она становится бесполезной.
TStr имеет свойство строкового типа.

Заголовочный файл `tstr.h` выглядит следующим образом.

@@@include
tstr/tstr.h
@@@

- 6: Использует `G_DECLARE_DERIVABLE_TYPE`.
Класс TStr является производным, и его дочерний класс будет определен позже.
- 8-12: TStrClass имеет один метод класса.
Это член `set_string` структуры TStrClass.
Он будет переопределен дочерним классом `TNumStr`.
Следовательно, и TStr, и TNumStr имеют член `set_string` в своих классах, но они указывают на разные функции.
- 14-15: Публичная функция `t_str_concat` соединяет две строки экземпляров TStr и возвращает новый экземпляр TStr.
- 18-22: Сеттер и геттер.
- 25-29: Функции для создания объекта TStr.

## C файл

C файл `tstr.c` для TStr выглядит следующим образом.

@@@include
tstr/tstr.c
@@@

- 3-9: `enum` определяет идентификатор свойства.
Член `PROP_STRING` является идентификатором свойства "string".
Здесь определено только одно свойство, поэтому можно определить его без `enum`.
Однако `enum` может быть применен для определения двух или более свойств, и это более распространено.
Последний член `N_PROPERTIES` равен двум, потому что `enum` начинается с нуля.
Массив `str_properties` имеет два элемента, так как `N_PROPERTIES` равно двум.
Первый элемент не используется и ему присваивается NULL.
Второму элементу будет присвоен указатель на экземпляр GParamSpec в функции инициализации класса.
- 11-13: TStrPrivate — это структура C.
Это область частных данных для TStr.
Если бы TStr был финальным типом, то потомков бы не существовало, и экземпляр TStr мог бы быть областью частных данных.
Но TStr является производным, поэтому вы не можете хранить такие частные данные в экземпляре TStr, который открыт для потомков.
Имя этой структуры — "<имя объекта\>Private", например `TStrPrivate`.
Структура должна быть определена до `G_DEFINE_TYPE_WITH_PRIVATE`.
- 15: Макрос `G_DEFINE_TYPE_WITH_PRIVATE`.
Он похож на макрос `G_DEFINE_TYPE`, но добавляет область частных данных для производного экземпляра.
Этот макрос раскрывается в:
  - Объявление `t_str_class_init`, которая является функцией инициализации класса.
  - Объявление `t_str_init`, которая является функцией инициализации экземпляра.
  - Определение статической переменной `t_str_parent_class`.
Она указывает на родительский класс TStr.
  - Вызов функции, которая добавляет частные данные экземпляра к типу.
Это структура C, и её имя — `TStrPrivate`.
  - Определение функции `t_str_get_type ()`.
Эта функция регистрирует тип при первом вызове.
  - Определение геттера частного экземпляра `t_str_get_instance_private ()`.
- 17-28: Функция `t_str_set_property` устанавливает свойство "string", и она используется семейством функций `g_object_set`.
Она использует функцию `t_str_set_string` для установки частных данных с копией строки из GValue.
Это важно, потому что `t_str_set_string` вызывает метод класса `set_string`, который будет переопределен дочерним классом.
Следовательно, поведение функции `t_str_set_property` различается между TStr и TNumStr, который является потомком TStr.
Функция `g_value_get_string` возвращает указатель на строку, которой владеет GValue.
Поэтому вам нужно дублировать строку, и это делается в функции `t_str_set_string`.
- 30-40: Функция `t_str_get_property` получает свойство "string", и она используется семейством функций `g_object_get`.
Она просто передает `priv->string` функции `g_value_set_string`.
Переменная `priv` указывает на область частных данных.
Второй аргумент `priv->string` принадлежит экземпляру TStr, и функция `g_value_set_string` дублирует его для хранения в структуре GValue.
- 44-51: Функция `t_str_real_set_string` является телом метода класса и на неё указывает член `set_string` в классе.
Сначала она получает указатель на частную область с помощью функции `t_str_get_instance_private`.
Если экземпляр содержит строку, освободите её перед установкой новой строки.
Она копирует данную строку и присваивает её `priv->string`.
Дублирование важно.
Благодаря этому адрес строки скрыт от внешней части экземпляра.
- 53-61: Функция финализации `t_str_finalize` вызывается, когда экземпляр TStr уничтожается.
Процесс уничтожения имеет две фазы: "dispose" и "finalize".
На фазе освобождения экземпляр освобождает экземпляры.
На фазе финализации экземпляр выполняет остальную часть финализации, например, освобождение памяти.
Эта функция освобождает строку `priv->string`, если необходимо.
После этого она вызывает метод финализации родителя.
Это называется "цепочка до родителя", и это будет объяснено позже в этом разделе.
- 63-68: Функция инициализации экземпляра `t_str_init` присваивает NULL `priv->string`.
- 70-81: Функция инициализации класса `t_str_class_init` переопределяет члены `finalize`, `set_property` и `get_property`.
Она создает экземпляр GParamSpec с помощью `g_param_spec_string` и устанавливает свойство с помощью `g_object_class_install_properties`.
Она присваивает `t_str_real_set_string` члену `set_string`.
Это метод класса, и ожидается, что он будет заменен в дочернем классе.
- 84-101: Сеттер и геттер.
Метод сеттера `t_str_set_string` просто вызывает метод класса.
Таким образом, ожидается, что он будет заменен в дочернем классе.
Он используется функцией установки свойства `t_str_set_property`.
Следовательно, поведение установки свойства изменится в дочернем классе.
Метод геттера `t_str_get_string` просто дублирует строку `priv->string` и возвращает копию.
- 103-126: Публичная функция `t_str_concat` объединяет строку `self` и `other` и создает новый TStr.
- 129-137: Две функции `t_str_new_with_string` и `t_str_new` создают новые экземпляры TStr.

## Цепочка до родителя

Процесс "цепочки до родителя" проиллюстрирован на диаграмме ниже.

![Процесс цепочки в GObject и TStr](../image/chainup.png){width=10.5cm height=9cm}

Есть два класса: GObjectClass и TStrClass.
Каждый класс имеет свои методы финализации (функции), на которые указывают указатели в структурах классов.
Метод финализации TStrClass финализирует свою собственную часть экземпляра TStr.
В конце функции он вызывает метод финализации родителя.
Это метод финализации GObjectClass.
Он вызывает свою собственную функцию финализации и финализирует частные данные GObject.

Если GObjectClass имеет два или более дочерних классов, количество функций финализации может быть таким же, как количество потомков.
И они соединены способом "цепочка до родителя".

![Процесс цепочки](../image/chainup3.png){width=12cm height=9cm}

## Как написать производный тип

- Используйте макрос `G_DECLARE_DERIVABLE_TYPE` в заголовочном файле.
Вам нужно написать макрос вроде `#define T_TYPE_STR (t_str_get_type ())` перед `G_DECLARE_DERIVABLE_TYPE`.
- Объявите структуру вашего класса в заголовочном файле.
Содержимое класса открыто для потомков.
Большинство членов являются методами класса.
- Используйте `G_DEFINE_TYPE_WITH_PRIVATE` в C файле.
Вам нужно определить частную область перед `G_DEFINE_TYPE_WITH_PRIVATE`.
Это структура C, и имя — "<имя объекта\>Private", например "TStrPrivate".
- Определите функции инициализации класса и экземпляра.

