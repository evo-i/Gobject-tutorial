Up: [Readme.md](../Readme.md),  Prev: [Section 6](sec6.md), Next: [Section 8](sec8.md)

# Производный и не абстрактный тип

Гораздо чаще создают не абстрактный производный тип, чем абстрактный тип.
Этот раздел описывает, как создавать объекты не абстрактного производного типа.
Примером производного типа является объект для строки.
Это TStr.
А его потомок — это объект для числовой строки.
Числовая строка — это строка, которая выражает число.
Например, "0", "-100" и "123.45".
Дочерний объект (числовая строка) будет объяснен в следующем разделе.

Этот раздел описывает управление памятью для строк перед производными объектами.

## Строка и управление памятью

TStr имеет значение строкового типа.
Это похоже на TInt или TDouble, но строка более сложна, чем int и double.
При создании программы TStr нужно быть внимательным к управлению памятью, что не требуется для TInt и TDouble.

### Строка и память

Строка — это массив символов, который завершается '\0'.
Строка не является типом C, таким как char, int, float или double.
Но указатель на массив символов ведет себя как строковый тип других языков.
Поэтому мы часто называем указатель строкой.

Если указатель равен NULL, он ни на что не указывает.
Таким образом, указатель не является строкой.
Программы со строками будут содержать ошибки, если вы не будете осторожны с NULL-указателем.

Другая раздражающая проблема — это выделение памяти.
Поскольку строка — это массив символов, выделение памяти необходимо для создания новой строки.
Мы не забываем выделять память, но часто забываем освобождать память.
Это вызывает утечку памяти.

~~~C
char *s;
s = g_strdup ("Hello.");
... ... ... do something with s
g_free (s);
~~~

`g_strdup` дублирует строку.
Она выполняет:

- Вычисляет размер строки.
Размер "Hello." равен 7, потому что строки завершаются нулем.
Строка — это массив 'H', 'e', 'l', 'l', 'o', '.' и ноль ('\0').
- Запрашивает у системы выделение 7 байт памяти.
- Копирует строку в память.
- Возвращает указатель на вновь выделенную память.
- Если аргумент равен NULL, то память не выделяется, и она возвращает NULL.

Если строка `s` больше не используется, `s` должна быть освобождена, что означает, что выделенные 7 байт должны быть возвращены системе.
`g_free` освобождает память.

Строки, ограниченные двойными кавычками, как "Hello.", являются строковыми литералами.
Они являются массивом символов, но содержимое массива не может быть изменено.
И они не должны быть освобождены.
Если вы записываете символ в строковый литерал или освобождаете строковый литерал, результат не определен.
Возможно, произойдут плохие вещи, например, ошибка сегментации.

Существует разница между массивами и указателями, когда вы инициализируете их строковым литералом.
Если массив инициализируется строковым литералом, массив может быть изменен.

~~~C
char a[]="Hello!";
a[1]='a';
g_print ("%s\n", a); /* Hallo will appear on your display. */
~~~

Первая строка инициализирует массив `a`.
Инициализация не простая.
Сначала компилятор вычисляет длину "Hello!".
Она равна семи, потому что строковый литерал имеет '\0' в конце.
Затем семь байт памяти выделяется в статической памяти или памяти стека.
Это зависит от класса массива, будь то `static` или `auto`.
Память инициализируется "Hello!".
Таким образом, строка в массиве может быть изменена.
Эта программа успешно отображает `Hallo!.

Первая строка программы выше эквивалентна следующей.

~~~C
char a[] = {'H', 'e', 'l', 'l', 'o', '!', '\0'};
~~~

Если вы определяете указатель со строковым литералом, вы не можете изменить строку, на которую указывает указатель.

~~~C
char *a = "Hello";
*(a+1) = 'a'; /* This is illegal. */
g_print ("%s\n", a);
~~~

Первая строка просто присваивает адрес строкового литерала переменной `a`.
Строковый литерал — это массив символов, но он доступен только для чтения.
Он может находиться в области кода программы или в какой-либо другой области, недоступной для записи.
Это зависит от реализации вашего компилятора.
Поэтому вторая строка пытается записать символ 'a' в память, доступную только для чтения, и результат не определен, например, происходит ошибка сегментации.
В любом случае, не пишите такую программу.

В заключение, строка — это массив символов, и она размещается в одном из следующих мест.

- Память только для чтения.
Строковый литерал доступен только для чтения.
- Стек.
Если класс массива `auto`, то массив размещается в стеке.
Стек доступен для записи.
Если массив определен в функции, его класс по умолчанию — `auto`.
Область стека исчезнет, когда функция вернется вызывающей стороне.
- Статическая область.
Если класс массива `static`, то массив размещается в статической области.
Он сохраняет свое значение и остается на протяжении всей жизни программы.
Эта область доступна для записи.
- Куча.
Вы можете выделять и освобождать память для строки.
Для выделения используется `g_new` или `g_new0`.
Для освобождения используется `g_free`.

### Копирование строки

Существует два способа копирования строки.
Первый способ — это просто копирование указателя.

~~~C
char *s = "Hello";
char *t = s;
~~~

Два указателя `s` и `t` указывают на один и тот же адрес.
Следовательно, вы не можете изменить `t`, потому что `t` указывает на строковый литерал, который доступен только для чтения.

Второй способ — это создание памяти и копирование строки в память.

~~~C
char *s = "Hello";
char *t = g_strdup (s);
~~~

Функция `g_strdup` выделяет память и инициализирует её "Hello", затем возвращает указатель на память.
Функция `g_strdup` почти идентична функции `string_dup` ниже.

~~~C
#include <glib-object.h>
#include <string.h>

char *
string_dup (char *s) {
  int length;
  char *t;

  if (s == NULL)
    return NULL;
  length = strlen (s) + 1;
  t = g_new (char, length);
  strcpy (t, s);
  return t;
}
~~~

Если используется `g_strdup`, два указателя `s` и `t` указывают на разные области памяти.
Вы можете изменить `t`, потому что он размещен в памяти, выделенной из области кучи.

Важно знать разницу между присваиванием указателей и дублированием строк.

### Квалификатор const

Квалификатор `const` делает так, что переменная не изменит свое значение.
Он также может быть применен к массиву.
Тогда элементы массива не будут изменены.

~~~C
const double pi = 3.1415926536;
const char a[] = "read only string";
~~~

Параметр массива в функции может быть квалифицирован с помощью `const`, чтобы указать, что функция не изменяет массив.
Точно так же возвращаемое значение (указатель на массив или строку) функции может быть квалифицировано с помощью `const`.
Вызывающая сторона не должна изменять или освобождать возвращенный массив или строку.

~~~C
char *
string_dup (const char *s) {
  ... ...
}

const char *
g_value_get_string (const GValue *value);
~~~

Квалификатор `const` указывает, кто является владельцем строки, когда он используется в функции объектов.
"Владелец" — это объект или вызывающая сторона функции, которая имеет право изменять или освобождать строку.

Например, `g_value_get_string` получает `const GValue *value` в качестве аргумента.
GValue, на которое указывает `value`, принадлежит вызывающей стороне, и функция не изменяет и не освобождает его.
Функция возвращает строку, квалифицированную с помощью `const`.
Возвращенная строка принадлежит объекту, и вызывающая сторона не должна изменять или освобождать строку.
Возможно, что строка будет изменена или освобождена объектом позже.

## Заголовочный файл

Остальная часть этого раздела посвящена TStr.
TStr является потомком GObject и содержит строку.
Строка — это указатель и массив символов.
Указатель указывает на массив.
Указатель может быть NULL.
Если он NULL, TStr не имеет массива.
Память массива берется из области кучи.
TStr владеет памятью и отвечает за её освобождение, когда она становится бесполезной.
TStr имеет свойство строкового типа.

Заголовочный файл `tstr.h` выглядит следующим образом.

~~~C
 1 #pragma once
 2 
 3 #include <glib-object.h>
 4 
 5 #define T_TYPE_STR  (t_str_get_type ())
 6 G_DECLARE_DERIVABLE_TYPE (TStr, t_str, T, STR, GObject)
 7 
 8 struct _TStrClass {
 9   GObjectClass parent_class;
10   /* expect that descendants will override the setter */
11   void (*set_string)  (TStr *self, const char *s);
12 };
13 
14 TStr *
15 t_str_concat (TStr *self, TStr *other);
16 
17 /* setter and getter */
18 void
19 t_str_set_string (TStr *self, const char *s);
20 
21 char *
22 t_str_get_string (TStr *self);
23 
24 /* create a new TStr instance */
25 TStr *
26 t_str_new_with_string (const char *s);
27 
28 TStr *
29 t_str_new (void);
~~~

- 6: Использует `G_DECLARE_DERIVABLE_TYPE`.
Класс TStr является производным, и его дочерний класс будет определен позже.
- 8-12: TStrClass имеет один метод класса.
Это член `set_string` структуры TStrClass.
Он будет переопределен дочерним классом `TNumStr`.
Следовательно, и TStr, и TNumStr имеют член `set_string` в своих классах, но они указывают на разные функции.
- 14-15: Публичная функция `t_str_concat` соединяет две строки экземпляров TStr и возвращает новый экземпляр TStr.
- 18-22: Сеттер и геттер.
- 25-29: Функции для создания объекта TStr.

## C файл

C файл `tstr.c` для TStr выглядит следующим образом.

~~~C
  1 #include "tstr.h"
  2 
  3 enum {
  4   PROP_0,
  5   PROP_STRING,
  6   N_PROPERTIES
  7 };
  8 
  9 static GParamSpec *str_properties[N_PROPERTIES] = {NULL, };
 10 
 11 typedef struct {
 12   char *string;
 13 } TStrPrivate;
 14 
 15 G_DEFINE_TYPE_WITH_PRIVATE(TStr, t_str, G_TYPE_OBJECT)
 16 
 17 static void
 18 t_str_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec) {
 19   TStr *self = T_STR (object);
 20 
 21 /* The returned value of the function g_value_get_string can be NULL. */
 22 /* The function t_str_set_string calls a class method, */
 23 /* which is expected to rewrite in the descendant object. */
 24   if (property_id == PROP_STRING)
 25     t_str_set_string (self, g_value_get_string (value));
 26   else
 27     G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
 28 }
 29 
 30 static void
 31 t_str_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec) {
 32   TStr *self = T_STR (object);
 33   TStrPrivate *priv = t_str_get_instance_private (self);
 34 
 35 /* The second argument of the function g_value_set_string can be NULL. */
 36   if (property_id == PROP_STRING)
 37     g_value_set_string (value, priv->string);
 38   else
 39     G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
 40 }
 41 
 42 /* This function just set the string. */
 43 /* So, no notify signal is emitted. */
 44 static void
 45 t_str_real_set_string (TStr *self, const char *s) {
 46   TStrPrivate *priv = t_str_get_instance_private (self);
 47 
 48   if (priv->string)
 49     g_free (priv->string);
 50   priv->string = g_strdup (s);
 51 }
 52 
 53 static void
 54 t_str_finalize (GObject *object) {
 55   TStr *self = T_STR (object);
 56   TStrPrivate *priv = t_str_get_instance_private (self);
 57 
 58   if (priv->string)
 59     g_free (priv->string);
 60   G_OBJECT_CLASS (t_str_parent_class)->finalize (object);
 61 }
 62 
 63 static void
 64 t_str_init (TStr *self) {
 65   TStrPrivate *priv = t_str_get_instance_private (self);
 66 
 67   priv->string = NULL;
 68 }
 69 
 70 static void
 71 t_str_class_init (TStrClass *class) {
 72   GObjectClass *gobject_class = G_OBJECT_CLASS (class);
 73 
 74   gobject_class->finalize = t_str_finalize;
 75   gobject_class->set_property = t_str_set_property;
 76   gobject_class->get_property = t_str_get_property;
 77   str_properties[PROP_STRING] = g_param_spec_string ("string", "str", "string", "", G_PARAM_READWRITE);
 78   g_object_class_install_properties (gobject_class, N_PROPERTIES, str_properties);
 79 
 80   class->set_string = t_str_real_set_string;
 81 }
 82 
 83 /* setter and getter */
 84 void
 85 t_str_set_string (TStr *self, const char *s) {
 86   g_return_if_fail (T_IS_STR (self));
 87   TStrClass *class = T_STR_GET_CLASS (self);
 88 
 89 /* The setter calls the class method 'set_string', */
 90 /* which is expected to be overridden by the descendant TNumStr. */
 91 /* Therefore, the behavior of the setter is different between TStr and TNumStr. */
 92   class->set_string (self, s);
 93 }
 94 
 95 char *
 96 t_str_get_string (TStr *self) {
 97   g_return_val_if_fail (T_IS_STR (self), NULL);
 98   TStrPrivate *priv = t_str_get_instance_private (self);
 99 
100   return g_strdup (priv->string);
101 }
102 
103 TStr *
104 t_str_concat (TStr *self, TStr *other) {
105   g_return_val_if_fail (T_IS_STR (self), NULL);
106   g_return_val_if_fail (T_IS_STR (other), NULL);
107 
108   char *s1, *s2, *s3;
109   TStr *str;
110 
111   s1 = t_str_get_string (self);
112   s2 = t_str_get_string (other);
113   if (s1 && s2)
114     s3 = g_strconcat (s1, s2, NULL);
115   else if (s1)
116     s3 = g_strdup (s1);
117   else if (s2)
118     s3 = g_strdup (s2);
119   else
120     s3 = NULL;
121   str = t_str_new_with_string (s3);
122   if (s1) g_free (s1);
123   if (s2) g_free (s2);
124   if (s3) g_free (s3);
125   return str;
126 }
127 
128 /* create a new TStr instance */
129 TStr *
130 t_str_new_with_string (const char *s) {
131   return T_STR (g_object_new (T_TYPE_STR, "string", s, NULL));
132 }
133 
134 TStr *
135 t_str_new (void) {
136   return T_STR (g_object_new (T_TYPE_STR, NULL));
137 }
~~~

- 3-9: `enum` определяет идентификатор свойства.
Член `PROP_STRING` является идентификатором свойства "string".
Здесь определено только одно свойство, поэтому можно определить его без `enum`.
Однако `enum` может быть применен для определения двух или более свойств, и это более распространено.
Последний член `N_PROPERTIES` равен двум, потому что `enum` начинается с нуля.
Массив `str_properties` имеет два элемента, так как `N_PROPERTIES` равно двум.
Первый элемент не используется и ему присваивается NULL.
Второму элементу будет присвоен указатель на экземпляр GParamSpec в функции инициализации класса.
- 11-13: TStrPrivate — это структура C.
Это область частных данных для TStr.
Если бы TStr был финальным типом, то потомков бы не существовало, и экземпляр TStr мог бы быть областью частных данных.
Но TStr является производным, поэтому вы не можете хранить такие частные данные в экземпляре TStr, который открыт для потомков.
Имя этой структуры — "<имя объекта\>Private", например `TStrPrivate`.
Структура должна быть определена до `G_DEFINE_TYPE_WITH_PRIVATE`.
- 15: Макрос `G_DEFINE_TYPE_WITH_PRIVATE`.
Он похож на макрос `G_DEFINE_TYPE`, но добавляет область частных данных для производного экземпляра.
Этот макрос раскрывается в:
  - Объявление `t_str_class_init`, которая является функцией инициализации класса.
  - Объявление `t_str_init`, которая является функцией инициализации экземпляра.
  - Определение статической переменной `t_str_parent_class`.
Она указывает на родительский класс TStr.
  - Вызов функции, которая добавляет частные данные экземпляра к типу.
Это структура C, и её имя — `TStrPrivate`.
  - Определение функции `t_str_get_type ()`.
Эта функция регистрирует тип при первом вызове.
  - Определение геттера частного экземпляра `t_str_get_instance_private ()`.
- 17-28: Функция `t_str_set_property` устанавливает свойство "string", и она используется семейством функций `g_object_set`.
Она использует функцию `t_str_set_string` для установки частных данных с копией строки из GValue.
Это важно, потому что `t_str_set_string` вызывает метод класса `set_string`, который будет переопределен дочерним классом.
Следовательно, поведение функции `t_str_set_property` различается между TStr и TNumStr, который является потомком TStr.
Функция `g_value_get_string` возвращает указатель на строку, которой владеет GValue.
Поэтому вам нужно дублировать строку, и это делается в функции `t_str_set_string`.
- 30-40: Функция `t_str_get_property` получает свойство "string", и она используется семейством функций `g_object_get`.
Она просто передает `priv->string` функции `g_value_set_string`.
Переменная `priv` указывает на область частных данных.
Второй аргумент `priv->string` принадлежит экземпляру TStr, и функция `g_value_set_string` дублирует его для хранения в структуре GValue.
- 44-51: Функция `t_str_real_set_string` является телом метода класса и на неё указывает член `set_string` в классе.
Сначала она получает указатель на частную область с помощью функции `t_str_get_instance_private`.
Если экземпляр содержит строку, освободите её перед установкой новой строки.
Она копирует данную строку и присваивает её `priv->string`.
Дублирование важно.
Благодаря этому адрес строки скрыт от внешней части экземпляра.
- 53-61: Функция финализации `t_str_finalize` вызывается, когда экземпляр TStr уничтожается.
Процесс уничтожения имеет две фазы: "dispose" и "finalize".
На фазе освобождения экземпляр освобождает экземпляры.
На фазе финализации экземпляр выполняет остальную часть финализации, например, освобождение памяти.
Эта функция освобождает строку `priv->string`, если необходимо.
После этого она вызывает метод финализации родителя.
Это называется "цепочка до родителя", и это будет объяснено позже в этом разделе.
- 63-68: Функция инициализации экземпляра `t_str_init` присваивает NULL `priv->string`.
- 70-81: Функция инициализации класса `t_str_class_init` переопределяет члены `finalize`, `set_property` и `get_property`.
Она создает экземпляр GParamSpec с помощью `g_param_spec_string` и устанавливает свойство с помощью `g_object_class_install_properties`.
Она присваивает `t_str_real_set_string` члену `set_string`.
Это метод класса, и ожидается, что он будет заменен в дочернем классе.
- 84-101: Сеттер и геттер.
Метод сеттера `t_str_set_string` просто вызывает метод класса.
Таким образом, ожидается, что он будет заменен в дочернем классе.
Он используется функцией установки свойства `t_str_set_property`.
Следовательно, поведение установки свойства изменится в дочернем классе.
Метод геттера `t_str_get_string` просто дублирует строку `priv->string` и возвращает копию.
- 103-126: Публичная функция `t_str_concat` объединяет строку `self` и `other` и создает новый TStr.
- 129-137: Две функции `t_str_new_with_string` и `t_str_new` создают новые экземпляры TStr.

## Цепочка до родителя

Процесс "цепочки до родителя" проиллюстрирован на диаграмме ниже.

![Процесс цепочки в GObject и TStr](../image/chainup.png)

Есть два класса: GObjectClass и TStrClass.
Каждый класс имеет свои методы финализации (функции), на которые указывают указатели в структурах классов.
Метод финализации TStrClass финализирует свою собственную часть экземпляра TStr.
В конце функции он вызывает метод финализации родителя.
Это метод финализации GObjectClass.
Он вызывает свою собственную функцию финализации и финализирует частные данные GObject.

Если GObjectClass имеет два или более дочерних классов, количество функций финализации может быть таким же, как количество потомков.
И они соединены способом "цепочка до родителя".

![Процесс цепочки](../image/chainup3.png)

## Как написать производный тип

- Используйте макрос `G_DECLARE_DERIVABLE_TYPE` в заголовочном файле.
Вам нужно написать макрос вроде `#define T_TYPE_STR (t_str_get_type ())` перед `G_DECLARE_DERIVABLE_TYPE`.
- Объявите структуру вашего класса в заголовочном файле.
Содержимое класса открыто для потомков.
Большинство членов являются методами класса.
- Используйте `G_DEFINE_TYPE_WITH_PRIVATE` в C файле.
Вам нужно определить частную область перед `G_DEFINE_TYPE_WITH_PRIVATE`.
Это структура C, и имя — "<имя объекта\>Private", например "TStrPrivate".
- Определите функции инициализации класса и экземпляра.


Up: [Readme.md](../Readme.md),  Prev: [Section 6](sec6.md), Next: [Section 8](sec8.md)
